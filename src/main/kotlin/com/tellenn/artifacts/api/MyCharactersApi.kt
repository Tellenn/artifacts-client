/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.tellenn.artifacts.api

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.tellenn.artifacts.api.models.BankExtensionTransactionResponseSchema
import com.tellenn.artifacts.api.models.BankGoldTransactionResponseSchema
import com.tellenn.artifacts.api.models.BankItemTransactionResponseSchema
import com.tellenn.artifacts.api.models.ChangeSkinCharacterSchema
import com.tellenn.artifacts.api.models.ChangeSkinResponseSchema
import com.tellenn.artifacts.api.models.CharacterFightResponseSchema
import com.tellenn.artifacts.api.models.CharacterMovementResponseSchema
import com.tellenn.artifacts.api.models.CharacterRestResponseSchema
import com.tellenn.artifacts.api.models.CraftingSchema
import com.tellenn.artifacts.api.models.DataPageLogSchema
import com.tellenn.artifacts.api.models.DeleteItemResponseSchema
import com.tellenn.artifacts.api.models.DepositWithdrawGoldSchema
import com.tellenn.artifacts.api.models.DestinationSchema
import com.tellenn.artifacts.api.models.EquipSchema
import com.tellenn.artifacts.api.models.EquipmentResponseSchema
import com.tellenn.artifacts.api.models.GEBuyOrderSchema
import com.tellenn.artifacts.api.models.GECancelOrderSchema
import com.tellenn.artifacts.api.models.GECreateOrderTransactionResponseSchema
import com.tellenn.artifacts.api.models.GEOrderCreationrSchema
import com.tellenn.artifacts.api.models.GETransactionResponseSchema
import com.tellenn.artifacts.api.models.GiveGoldReponseSchema
import com.tellenn.artifacts.api.models.GiveGoldSchema
import com.tellenn.artifacts.api.models.GiveItemReponseSchema
import com.tellenn.artifacts.api.models.GiveItemsSchema
import com.tellenn.artifacts.api.models.MyCharactersListSchema
import com.tellenn.artifacts.api.models.NpcMerchantBuySchema
import com.tellenn.artifacts.api.models.NpcMerchantTransactionResponseSchema
import com.tellenn.artifacts.api.models.RecyclingResponseSchema
import com.tellenn.artifacts.api.models.RecyclingSchema
import com.tellenn.artifacts.api.models.RewardDataResponseSchema
import com.tellenn.artifacts.api.models.SimpleItemSchema
import com.tellenn.artifacts.api.models.SkillResponseSchema
import com.tellenn.artifacts.api.models.TaskCancelledResponseSchema
import com.tellenn.artifacts.api.models.TaskResponseSchema
import com.tellenn.artifacts.api.models.TaskTradeResponseSchema
import com.tellenn.artifacts.api.models.UnequipSchema
import com.tellenn.artifacts.api.models.UseItemResponseSchema

import com.fasterxml.jackson.annotation.JsonProperty

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import com.tellenn.artifacts.api.infrastructure.ApiClient
import com.tellenn.artifacts.api.infrastructure.ApiResponse
import com.tellenn.artifacts.api.infrastructure.ClientException
import com.tellenn.artifacts.api.infrastructure.ClientError
import com.tellenn.artifacts.api.infrastructure.ServerException
import com.tellenn.artifacts.api.infrastructure.ServerError
import com.tellenn.artifacts.api.infrastructure.MultiValueMap
import com.tellenn.artifacts.api.infrastructure.PartConfig
import com.tellenn.artifacts.api.infrastructure.RequestConfig
import com.tellenn.artifacts.api.infrastructure.RequestMethod
import com.tellenn.artifacts.api.infrastructure.ResponseType
import com.tellenn.artifacts.api.infrastructure.Success
import com.tellenn.artifacts.api.infrastructure.toMultiValue

class MyCharactersApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Action Accept New Task
     * Accepting a new task.
     * @param name Name of your character.
     * @return TaskResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionAcceptNewTaskMyNameActionTaskNewPost(name: kotlin.String) : TaskResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionAcceptNewTaskMyNameActionTaskNewPostWithHttpInfo(name = name)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaskResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Accept New Task
     * Accepting a new task.
     * @param name Name of your character.
     * @return ApiResponse<TaskResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionAcceptNewTaskMyNameActionTaskNewPostWithHttpInfo(name: kotlin.String) : ApiResponse<TaskResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionAcceptNewTaskMyNameActionTaskNewPostRequestConfig(name = name)

        return@withContext request<Unit, TaskResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionAcceptNewTaskMyNameActionTaskNewPost
     *
     * @param name Name of your character.
     * @return RequestConfig
     */
    fun actionAcceptNewTaskMyNameActionTaskNewPostRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/task/new".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Buy Bank Expansion
     * Buy a 25 slots bank expansion.
     * @param name Name of your character.
     * @return BankExtensionTransactionResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionBuyBankExpansionMyNameActionBankBuyExpansionPost(name: kotlin.String) : BankExtensionTransactionResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionBuyBankExpansionMyNameActionBankBuyExpansionPostWithHttpInfo(name = name)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BankExtensionTransactionResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Buy Bank Expansion
     * Buy a 25 slots bank expansion.
     * @param name Name of your character.
     * @return ApiResponse<BankExtensionTransactionResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionBuyBankExpansionMyNameActionBankBuyExpansionPostWithHttpInfo(name: kotlin.String) : ApiResponse<BankExtensionTransactionResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionBuyBankExpansionMyNameActionBankBuyExpansionPostRequestConfig(name = name)

        return@withContext request<Unit, BankExtensionTransactionResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionBuyBankExpansionMyNameActionBankBuyExpansionPost
     *
     * @param name Name of your character.
     * @return RequestConfig
     */
    fun actionBuyBankExpansionMyNameActionBankBuyExpansionPostRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/bank/buy_expansion".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Change Skin
     * Change the skin of your character.
     * @param name Name of your character.
     * @param changeSkinCharacterSchema 
     * @return ChangeSkinResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionChangeSkinMyNameActionChangeSkinPost(name: kotlin.String, changeSkinCharacterSchema: ChangeSkinCharacterSchema) : ChangeSkinResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionChangeSkinMyNameActionChangeSkinPostWithHttpInfo(name = name, changeSkinCharacterSchema = changeSkinCharacterSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ChangeSkinResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Change Skin
     * Change the skin of your character.
     * @param name Name of your character.
     * @param changeSkinCharacterSchema 
     * @return ApiResponse<ChangeSkinResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionChangeSkinMyNameActionChangeSkinPostWithHttpInfo(name: kotlin.String, changeSkinCharacterSchema: ChangeSkinCharacterSchema) : ApiResponse<ChangeSkinResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionChangeSkinMyNameActionChangeSkinPostRequestConfig(name = name, changeSkinCharacterSchema = changeSkinCharacterSchema)

        return@withContext request<ChangeSkinCharacterSchema, ChangeSkinResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionChangeSkinMyNameActionChangeSkinPost
     *
     * @param name Name of your character.
     * @param changeSkinCharacterSchema 
     * @return RequestConfig
     */
    fun actionChangeSkinMyNameActionChangeSkinPostRequestConfig(name: kotlin.String, changeSkinCharacterSchema: ChangeSkinCharacterSchema) : RequestConfig<ChangeSkinCharacterSchema> {
        val localVariableBody = changeSkinCharacterSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/change_skin".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Complete Task
     * Complete a task.
     * @param name Name of your character.
     * @return RewardDataResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionCompleteTaskMyNameActionTaskCompletePost(name: kotlin.String) : RewardDataResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionCompleteTaskMyNameActionTaskCompletePostWithHttpInfo(name = name)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RewardDataResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Complete Task
     * Complete a task.
     * @param name Name of your character.
     * @return ApiResponse<RewardDataResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionCompleteTaskMyNameActionTaskCompletePostWithHttpInfo(name: kotlin.String) : ApiResponse<RewardDataResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionCompleteTaskMyNameActionTaskCompletePostRequestConfig(name = name)

        return@withContext request<Unit, RewardDataResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionCompleteTaskMyNameActionTaskCompletePost
     *
     * @param name Name of your character.
     * @return RequestConfig
     */
    fun actionCompleteTaskMyNameActionTaskCompletePostRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/task/complete".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Crafting
     * Crafting an item. The character must be on a map with a workshop.
     * @param name Name of your character.
     * @param craftingSchema 
     * @return SkillResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionCraftingMyNameActionCraftingPost(name: kotlin.String, craftingSchema: CraftingSchema) : SkillResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionCraftingMyNameActionCraftingPostWithHttpInfo(name = name, craftingSchema = craftingSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SkillResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Crafting
     * Crafting an item. The character must be on a map with a workshop.
     * @param name Name of your character.
     * @param craftingSchema 
     * @return ApiResponse<SkillResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionCraftingMyNameActionCraftingPostWithHttpInfo(name: kotlin.String, craftingSchema: CraftingSchema) : ApiResponse<SkillResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionCraftingMyNameActionCraftingPostRequestConfig(name = name, craftingSchema = craftingSchema)

        return@withContext request<CraftingSchema, SkillResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionCraftingMyNameActionCraftingPost
     *
     * @param name Name of your character.
     * @param craftingSchema 
     * @return RequestConfig
     */
    fun actionCraftingMyNameActionCraftingPostRequestConfig(name: kotlin.String, craftingSchema: CraftingSchema) : RequestConfig<CraftingSchema> {
        val localVariableBody = craftingSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/crafting".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Delete Item
     * Delete an item from your character&#39;s inventory.
     * @param name Name of your character.
     * @param simpleItemSchema 
     * @return DeleteItemResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionDeleteItemMyNameActionDeletePost(name: kotlin.String, simpleItemSchema: SimpleItemSchema) : DeleteItemResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionDeleteItemMyNameActionDeletePostWithHttpInfo(name = name, simpleItemSchema = simpleItemSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteItemResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Delete Item
     * Delete an item from your character&#39;s inventory.
     * @param name Name of your character.
     * @param simpleItemSchema 
     * @return ApiResponse<DeleteItemResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionDeleteItemMyNameActionDeletePostWithHttpInfo(name: kotlin.String, simpleItemSchema: SimpleItemSchema) : ApiResponse<DeleteItemResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionDeleteItemMyNameActionDeletePostRequestConfig(name = name, simpleItemSchema = simpleItemSchema)

        return@withContext request<SimpleItemSchema, DeleteItemResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionDeleteItemMyNameActionDeletePost
     *
     * @param name Name of your character.
     * @param simpleItemSchema 
     * @return RequestConfig
     */
    fun actionDeleteItemMyNameActionDeletePostRequestConfig(name: kotlin.String, simpleItemSchema: SimpleItemSchema) : RequestConfig<SimpleItemSchema> {
        val localVariableBody = simpleItemSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/delete".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Deposit Bank Gold
     * Deposit gold in a bank on the character&#39;s map.
     * @param name Name of your character.
     * @param depositWithdrawGoldSchema 
     * @return BankGoldTransactionResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionDepositBankGoldMyNameActionBankDepositGoldPost(name: kotlin.String, depositWithdrawGoldSchema: DepositWithdrawGoldSchema) : BankGoldTransactionResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionDepositBankGoldMyNameActionBankDepositGoldPostWithHttpInfo(name = name, depositWithdrawGoldSchema = depositWithdrawGoldSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BankGoldTransactionResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Deposit Bank Gold
     * Deposit gold in a bank on the character&#39;s map.
     * @param name Name of your character.
     * @param depositWithdrawGoldSchema 
     * @return ApiResponse<BankGoldTransactionResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionDepositBankGoldMyNameActionBankDepositGoldPostWithHttpInfo(name: kotlin.String, depositWithdrawGoldSchema: DepositWithdrawGoldSchema) : ApiResponse<BankGoldTransactionResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionDepositBankGoldMyNameActionBankDepositGoldPostRequestConfig(name = name, depositWithdrawGoldSchema = depositWithdrawGoldSchema)

        return@withContext request<DepositWithdrawGoldSchema, BankGoldTransactionResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionDepositBankGoldMyNameActionBankDepositGoldPost
     *
     * @param name Name of your character.
     * @param depositWithdrawGoldSchema 
     * @return RequestConfig
     */
    fun actionDepositBankGoldMyNameActionBankDepositGoldPostRequestConfig(name: kotlin.String, depositWithdrawGoldSchema: DepositWithdrawGoldSchema) : RequestConfig<DepositWithdrawGoldSchema> {
        val localVariableBody = depositWithdrawGoldSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/bank/deposit/gold".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Deposit Bank Item
     * Deposit multiple items in a bank on the character&#39;s map. The cooldown will be 3 seconds multiplied by the number of different items withdrawn.
     * @param name Name of your character.
     * @param simpleItemSchema 
     * @return BankItemTransactionResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionDepositBankItemMyNameActionBankDepositItemPost(name: kotlin.String, simpleItemSchema: kotlin.collections.List<SimpleItemSchema>) : BankItemTransactionResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionDepositBankItemMyNameActionBankDepositItemPostWithHttpInfo(name = name, simpleItemSchema = simpleItemSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BankItemTransactionResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Deposit Bank Item
     * Deposit multiple items in a bank on the character&#39;s map. The cooldown will be 3 seconds multiplied by the number of different items withdrawn.
     * @param name Name of your character.
     * @param simpleItemSchema 
     * @return ApiResponse<BankItemTransactionResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionDepositBankItemMyNameActionBankDepositItemPostWithHttpInfo(name: kotlin.String, simpleItemSchema: kotlin.collections.List<SimpleItemSchema>) : ApiResponse<BankItemTransactionResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionDepositBankItemMyNameActionBankDepositItemPostRequestConfig(name = name, simpleItemSchema = simpleItemSchema)

        return@withContext request<kotlin.collections.List<SimpleItemSchema>, BankItemTransactionResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionDepositBankItemMyNameActionBankDepositItemPost
     *
     * @param name Name of your character.
     * @param simpleItemSchema 
     * @return RequestConfig
     */
    fun actionDepositBankItemMyNameActionBankDepositItemPostRequestConfig(name: kotlin.String, simpleItemSchema: kotlin.collections.List<SimpleItemSchema>) : RequestConfig<kotlin.collections.List<SimpleItemSchema>> {
        val localVariableBody = simpleItemSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/bank/deposit/item".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Equip Item
     * Equip an item on your character.
     * @param name Name of your character.
     * @param equipSchema 
     * @return EquipmentResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionEquipItemMyNameActionEquipPost(name: kotlin.String, equipSchema: EquipSchema) : EquipmentResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionEquipItemMyNameActionEquipPostWithHttpInfo(name = name, equipSchema = equipSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EquipmentResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Equip Item
     * Equip an item on your character.
     * @param name Name of your character.
     * @param equipSchema 
     * @return ApiResponse<EquipmentResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionEquipItemMyNameActionEquipPostWithHttpInfo(name: kotlin.String, equipSchema: EquipSchema) : ApiResponse<EquipmentResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionEquipItemMyNameActionEquipPostRequestConfig(name = name, equipSchema = equipSchema)

        return@withContext request<EquipSchema, EquipmentResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionEquipItemMyNameActionEquipPost
     *
     * @param name Name of your character.
     * @param equipSchema 
     * @return RequestConfig
     */
    fun actionEquipItemMyNameActionEquipPostRequestConfig(name: kotlin.String, equipSchema: EquipSchema) : RequestConfig<EquipSchema> {
        val localVariableBody = equipSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/equip".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Fight
     * Start a fight against a monster on the character&#39;s map.
     * @param name Name of your character.
     * @return CharacterFightResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionFightMyNameActionFightPost(name: kotlin.String) : CharacterFightResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionFightMyNameActionFightPostWithHttpInfo(name = name)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CharacterFightResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Fight
     * Start a fight against a monster on the character&#39;s map.
     * @param name Name of your character.
     * @return ApiResponse<CharacterFightResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionFightMyNameActionFightPostWithHttpInfo(name: kotlin.String) : ApiResponse<CharacterFightResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionFightMyNameActionFightPostRequestConfig(name = name)

        return@withContext request<Unit, CharacterFightResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionFightMyNameActionFightPost
     *
     * @param name Name of your character.
     * @return RequestConfig
     */
    fun actionFightMyNameActionFightPostRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/fight".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Gathering
     * Harvest a resource on the character&#39;s map.
     * @param name Name of your character.
     * @return SkillResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionGatheringMyNameActionGatheringPost(name: kotlin.String) : SkillResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionGatheringMyNameActionGatheringPostWithHttpInfo(name = name)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SkillResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Gathering
     * Harvest a resource on the character&#39;s map.
     * @param name Name of your character.
     * @return ApiResponse<SkillResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionGatheringMyNameActionGatheringPostWithHttpInfo(name: kotlin.String) : ApiResponse<SkillResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionGatheringMyNameActionGatheringPostRequestConfig(name = name)

        return@withContext request<Unit, SkillResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionGatheringMyNameActionGatheringPost
     *
     * @param name Name of your character.
     * @return RequestConfig
     */
    fun actionGatheringMyNameActionGatheringPostRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/gathering".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Ge Buy Item
     * Buy an item at the Grand Exchange on the character&#39;s map.
     * @param name Name of your character.
     * @param geBuyOrderSchema 
     * @return GETransactionResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionGeBuyItemMyNameActionGrandexchangeBuyPost(name: kotlin.String, geBuyOrderSchema: GEBuyOrderSchema) : GETransactionResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionGeBuyItemMyNameActionGrandexchangeBuyPostWithHttpInfo(name = name, geBuyOrderSchema = geBuyOrderSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GETransactionResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Ge Buy Item
     * Buy an item at the Grand Exchange on the character&#39;s map.
     * @param name Name of your character.
     * @param geBuyOrderSchema 
     * @return ApiResponse<GETransactionResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionGeBuyItemMyNameActionGrandexchangeBuyPostWithHttpInfo(name: kotlin.String, geBuyOrderSchema: GEBuyOrderSchema) : ApiResponse<GETransactionResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionGeBuyItemMyNameActionGrandexchangeBuyPostRequestConfig(name = name, geBuyOrderSchema = geBuyOrderSchema)

        return@withContext request<GEBuyOrderSchema, GETransactionResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionGeBuyItemMyNameActionGrandexchangeBuyPost
     *
     * @param name Name of your character.
     * @param geBuyOrderSchema 
     * @return RequestConfig
     */
    fun actionGeBuyItemMyNameActionGrandexchangeBuyPostRequestConfig(name: kotlin.String, geBuyOrderSchema: GEBuyOrderSchema) : RequestConfig<GEBuyOrderSchema> {
        val localVariableBody = geBuyOrderSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/grandexchange/buy".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Ge Cancel Sell Order
     * Cancel a sell order at the Grand Exchange on the character&#39;s map.
     * @param name Name of your character.
     * @param geCancelOrderSchema 
     * @return GETransactionResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionGeCancelSellOrderMyNameActionGrandexchangeCancelPost(name: kotlin.String, geCancelOrderSchema: GECancelOrderSchema) : GETransactionResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionGeCancelSellOrderMyNameActionGrandexchangeCancelPostWithHttpInfo(name = name, geCancelOrderSchema = geCancelOrderSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GETransactionResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Ge Cancel Sell Order
     * Cancel a sell order at the Grand Exchange on the character&#39;s map.
     * @param name Name of your character.
     * @param geCancelOrderSchema 
     * @return ApiResponse<GETransactionResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionGeCancelSellOrderMyNameActionGrandexchangeCancelPostWithHttpInfo(name: kotlin.String, geCancelOrderSchema: GECancelOrderSchema) : ApiResponse<GETransactionResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionGeCancelSellOrderMyNameActionGrandexchangeCancelPostRequestConfig(name = name, geCancelOrderSchema = geCancelOrderSchema)

        return@withContext request<GECancelOrderSchema, GETransactionResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionGeCancelSellOrderMyNameActionGrandexchangeCancelPost
     *
     * @param name Name of your character.
     * @param geCancelOrderSchema 
     * @return RequestConfig
     */
    fun actionGeCancelSellOrderMyNameActionGrandexchangeCancelPostRequestConfig(name: kotlin.String, geCancelOrderSchema: GECancelOrderSchema) : RequestConfig<GECancelOrderSchema> {
        val localVariableBody = geCancelOrderSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/grandexchange/cancel".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Ge Create Sell Order
     * Create a sell order at the Grand Exchange on the character&#39;s map. Please note there is a 3% listing tax, charged at the time of posting, on the total price.
     * @param name Name of your character.
     * @param geOrderCreationrSchema 
     * @return GECreateOrderTransactionResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionGeCreateSellOrderMyNameActionGrandexchangeSellPost(name: kotlin.String, geOrderCreationrSchema: GEOrderCreationrSchema) : GECreateOrderTransactionResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionGeCreateSellOrderMyNameActionGrandexchangeSellPostWithHttpInfo(name = name, geOrderCreationrSchema = geOrderCreationrSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GECreateOrderTransactionResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Ge Create Sell Order
     * Create a sell order at the Grand Exchange on the character&#39;s map. Please note there is a 3% listing tax, charged at the time of posting, on the total price.
     * @param name Name of your character.
     * @param geOrderCreationrSchema 
     * @return ApiResponse<GECreateOrderTransactionResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionGeCreateSellOrderMyNameActionGrandexchangeSellPostWithHttpInfo(name: kotlin.String, geOrderCreationrSchema: GEOrderCreationrSchema) : ApiResponse<GECreateOrderTransactionResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionGeCreateSellOrderMyNameActionGrandexchangeSellPostRequestConfig(name = name, geOrderCreationrSchema = geOrderCreationrSchema)

        return@withContext request<GEOrderCreationrSchema, GECreateOrderTransactionResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionGeCreateSellOrderMyNameActionGrandexchangeSellPost
     *
     * @param name Name of your character.
     * @param geOrderCreationrSchema 
     * @return RequestConfig
     */
    fun actionGeCreateSellOrderMyNameActionGrandexchangeSellPostRequestConfig(name: kotlin.String, geOrderCreationrSchema: GEOrderCreationrSchema) : RequestConfig<GEOrderCreationrSchema> {
        val localVariableBody = geOrderCreationrSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/grandexchange/sell".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Give Gold
     * Give gold to another character in your account on the same map.
     * @param name Name of your character.
     * @param giveGoldSchema 
     * @return GiveGoldReponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionGiveGoldMyNameActionGiveGoldPost(name: kotlin.String, giveGoldSchema: GiveGoldSchema) : GiveGoldReponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionGiveGoldMyNameActionGiveGoldPostWithHttpInfo(name = name, giveGoldSchema = giveGoldSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GiveGoldReponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Give Gold
     * Give gold to another character in your account on the same map.
     * @param name Name of your character.
     * @param giveGoldSchema 
     * @return ApiResponse<GiveGoldReponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionGiveGoldMyNameActionGiveGoldPostWithHttpInfo(name: kotlin.String, giveGoldSchema: GiveGoldSchema) : ApiResponse<GiveGoldReponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionGiveGoldMyNameActionGiveGoldPostRequestConfig(name = name, giveGoldSchema = giveGoldSchema)

        return@withContext request<GiveGoldSchema, GiveGoldReponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionGiveGoldMyNameActionGiveGoldPost
     *
     * @param name Name of your character.
     * @param giveGoldSchema 
     * @return RequestConfig
     */
    fun actionGiveGoldMyNameActionGiveGoldPostRequestConfig(name: kotlin.String, giveGoldSchema: GiveGoldSchema) : RequestConfig<GiveGoldSchema> {
        val localVariableBody = giveGoldSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/give/gold".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Give Items
     * Give items to another character in your account on the same map. The cooldown will be 3 seconds multiplied by the number of different items given.
     * @param name Name of your character.
     * @param giveItemsSchema 
     * @return GiveItemReponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionGiveItemsMyNameActionGiveItemPost(name: kotlin.String, giveItemsSchema: GiveItemsSchema) : GiveItemReponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionGiveItemsMyNameActionGiveItemPostWithHttpInfo(name = name, giveItemsSchema = giveItemsSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GiveItemReponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Give Items
     * Give items to another character in your account on the same map. The cooldown will be 3 seconds multiplied by the number of different items given.
     * @param name Name of your character.
     * @param giveItemsSchema 
     * @return ApiResponse<GiveItemReponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionGiveItemsMyNameActionGiveItemPostWithHttpInfo(name: kotlin.String, giveItemsSchema: GiveItemsSchema) : ApiResponse<GiveItemReponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionGiveItemsMyNameActionGiveItemPostRequestConfig(name = name, giveItemsSchema = giveItemsSchema)

        return@withContext request<GiveItemsSchema, GiveItemReponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionGiveItemsMyNameActionGiveItemPost
     *
     * @param name Name of your character.
     * @param giveItemsSchema 
     * @return RequestConfig
     */
    fun actionGiveItemsMyNameActionGiveItemPostRequestConfig(name: kotlin.String, giveItemsSchema: GiveItemsSchema) : RequestConfig<GiveItemsSchema> {
        val localVariableBody = giveItemsSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/give/item".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Move
     * Moves a character on the map using the map&#39;s X and Y position.
     * @param name Name of your character.
     * @param destinationSchema 
     * @return CharacterMovementResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionMoveMyNameActionMovePost(name: kotlin.String, destinationSchema: DestinationSchema) : CharacterMovementResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionMoveMyNameActionMovePostWithHttpInfo(name = name, destinationSchema = destinationSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CharacterMovementResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Move
     * Moves a character on the map using the map&#39;s X and Y position.
     * @param name Name of your character.
     * @param destinationSchema 
     * @return ApiResponse<CharacterMovementResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionMoveMyNameActionMovePostWithHttpInfo(name: kotlin.String, destinationSchema: DestinationSchema) : ApiResponse<CharacterMovementResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionMoveMyNameActionMovePostRequestConfig(name = name, destinationSchema = destinationSchema)

        return@withContext request<DestinationSchema, CharacterMovementResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionMoveMyNameActionMovePost
     *
     * @param name Name of your character.
     * @param destinationSchema 
     * @return RequestConfig
     */
    fun actionMoveMyNameActionMovePostRequestConfig(name: kotlin.String, destinationSchema: DestinationSchema) : RequestConfig<DestinationSchema> {
        val localVariableBody = destinationSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/move".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Npc Buy Item
     * Buy an item from an NPC on the character&#39;s map.
     * @param name Name of your character.
     * @param npcMerchantBuySchema 
     * @return NpcMerchantTransactionResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionNpcBuyItemMyNameActionNpcBuyPost(name: kotlin.String, npcMerchantBuySchema: NpcMerchantBuySchema) : NpcMerchantTransactionResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionNpcBuyItemMyNameActionNpcBuyPostWithHttpInfo(name = name, npcMerchantBuySchema = npcMerchantBuySchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NpcMerchantTransactionResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Npc Buy Item
     * Buy an item from an NPC on the character&#39;s map.
     * @param name Name of your character.
     * @param npcMerchantBuySchema 
     * @return ApiResponse<NpcMerchantTransactionResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionNpcBuyItemMyNameActionNpcBuyPostWithHttpInfo(name: kotlin.String, npcMerchantBuySchema: NpcMerchantBuySchema) : ApiResponse<NpcMerchantTransactionResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionNpcBuyItemMyNameActionNpcBuyPostRequestConfig(name = name, npcMerchantBuySchema = npcMerchantBuySchema)

        return@withContext request<NpcMerchantBuySchema, NpcMerchantTransactionResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionNpcBuyItemMyNameActionNpcBuyPost
     *
     * @param name Name of your character.
     * @param npcMerchantBuySchema 
     * @return RequestConfig
     */
    fun actionNpcBuyItemMyNameActionNpcBuyPostRequestConfig(name: kotlin.String, npcMerchantBuySchema: NpcMerchantBuySchema) : RequestConfig<NpcMerchantBuySchema> {
        val localVariableBody = npcMerchantBuySchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/npc/buy".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Npc Sell Item
     * Sell an item to an NPC on the character&#39;s map.
     * @param name Name of your character.
     * @param npcMerchantBuySchema 
     * @return NpcMerchantTransactionResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionNpcSellItemMyNameActionNpcSellPost(name: kotlin.String, npcMerchantBuySchema: NpcMerchantBuySchema) : NpcMerchantTransactionResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionNpcSellItemMyNameActionNpcSellPostWithHttpInfo(name = name, npcMerchantBuySchema = npcMerchantBuySchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NpcMerchantTransactionResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Npc Sell Item
     * Sell an item to an NPC on the character&#39;s map.
     * @param name Name of your character.
     * @param npcMerchantBuySchema 
     * @return ApiResponse<NpcMerchantTransactionResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionNpcSellItemMyNameActionNpcSellPostWithHttpInfo(name: kotlin.String, npcMerchantBuySchema: NpcMerchantBuySchema) : ApiResponse<NpcMerchantTransactionResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionNpcSellItemMyNameActionNpcSellPostRequestConfig(name = name, npcMerchantBuySchema = npcMerchantBuySchema)

        return@withContext request<NpcMerchantBuySchema, NpcMerchantTransactionResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionNpcSellItemMyNameActionNpcSellPost
     *
     * @param name Name of your character.
     * @param npcMerchantBuySchema 
     * @return RequestConfig
     */
    fun actionNpcSellItemMyNameActionNpcSellPostRequestConfig(name: kotlin.String, npcMerchantBuySchema: NpcMerchantBuySchema) : RequestConfig<NpcMerchantBuySchema> {
        val localVariableBody = npcMerchantBuySchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/npc/sell".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Recycling
     * Recycling an item. The character must be on a map with a workshop (only for equipments and weapons).
     * @param name Name of your character.
     * @param recyclingSchema 
     * @return RecyclingResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionRecyclingMyNameActionRecyclingPost(name: kotlin.String, recyclingSchema: RecyclingSchema) : RecyclingResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionRecyclingMyNameActionRecyclingPostWithHttpInfo(name = name, recyclingSchema = recyclingSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RecyclingResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Recycling
     * Recycling an item. The character must be on a map with a workshop (only for equipments and weapons).
     * @param name Name of your character.
     * @param recyclingSchema 
     * @return ApiResponse<RecyclingResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionRecyclingMyNameActionRecyclingPostWithHttpInfo(name: kotlin.String, recyclingSchema: RecyclingSchema) : ApiResponse<RecyclingResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionRecyclingMyNameActionRecyclingPostRequestConfig(name = name, recyclingSchema = recyclingSchema)

        return@withContext request<RecyclingSchema, RecyclingResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionRecyclingMyNameActionRecyclingPost
     *
     * @param name Name of your character.
     * @param recyclingSchema 
     * @return RequestConfig
     */
    fun actionRecyclingMyNameActionRecyclingPostRequestConfig(name: kotlin.String, recyclingSchema: RecyclingSchema) : RequestConfig<RecyclingSchema> {
        val localVariableBody = recyclingSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/recycling".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Rest
     * Recovers hit points by resting. (1 second per 5 HP, minimum 3 seconds)
     * @param name Name of your character.
     * @return CharacterRestResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionRestMyNameActionRestPost(name: kotlin.String) : CharacterRestResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionRestMyNameActionRestPostWithHttpInfo(name = name)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CharacterRestResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Rest
     * Recovers hit points by resting. (1 second per 5 HP, minimum 3 seconds)
     * @param name Name of your character.
     * @return ApiResponse<CharacterRestResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionRestMyNameActionRestPostWithHttpInfo(name: kotlin.String) : ApiResponse<CharacterRestResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionRestMyNameActionRestPostRequestConfig(name = name)

        return@withContext request<Unit, CharacterRestResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionRestMyNameActionRestPost
     *
     * @param name Name of your character.
     * @return RequestConfig
     */
    fun actionRestMyNameActionRestPostRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/rest".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Task Cancel
     * Cancel a task for 1 tasks coin.
     * @param name Name of your character.
     * @return TaskCancelledResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionTaskCancelMyNameActionTaskCancelPost(name: kotlin.String) : TaskCancelledResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionTaskCancelMyNameActionTaskCancelPostWithHttpInfo(name = name)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaskCancelledResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Task Cancel
     * Cancel a task for 1 tasks coin.
     * @param name Name of your character.
     * @return ApiResponse<TaskCancelledResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionTaskCancelMyNameActionTaskCancelPostWithHttpInfo(name: kotlin.String) : ApiResponse<TaskCancelledResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionTaskCancelMyNameActionTaskCancelPostRequestConfig(name = name)

        return@withContext request<Unit, TaskCancelledResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionTaskCancelMyNameActionTaskCancelPost
     *
     * @param name Name of your character.
     * @return RequestConfig
     */
    fun actionTaskCancelMyNameActionTaskCancelPostRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/task/cancel".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Task Exchange
     * Exchange 6 tasks coins for a random reward. Rewards are exclusive items or resources.
     * @param name Name of your character.
     * @return RewardDataResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionTaskExchangeMyNameActionTaskExchangePost(name: kotlin.String) : RewardDataResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionTaskExchangeMyNameActionTaskExchangePostWithHttpInfo(name = name)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RewardDataResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Task Exchange
     * Exchange 6 tasks coins for a random reward. Rewards are exclusive items or resources.
     * @param name Name of your character.
     * @return ApiResponse<RewardDataResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionTaskExchangeMyNameActionTaskExchangePostWithHttpInfo(name: kotlin.String) : ApiResponse<RewardDataResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionTaskExchangeMyNameActionTaskExchangePostRequestConfig(name = name)

        return@withContext request<Unit, RewardDataResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionTaskExchangeMyNameActionTaskExchangePost
     *
     * @param name Name of your character.
     * @return RequestConfig
     */
    fun actionTaskExchangeMyNameActionTaskExchangePostRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/task/exchange".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Task Trade
     * Trading items with a Tasks Master.
     * @param name Name of your character.
     * @param simpleItemSchema 
     * @return TaskTradeResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionTaskTradeMyNameActionTaskTradePost(name: kotlin.String, simpleItemSchema: SimpleItemSchema) : TaskTradeResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionTaskTradeMyNameActionTaskTradePostWithHttpInfo(name = name, simpleItemSchema = simpleItemSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TaskTradeResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Task Trade
     * Trading items with a Tasks Master.
     * @param name Name of your character.
     * @param simpleItemSchema 
     * @return ApiResponse<TaskTradeResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionTaskTradeMyNameActionTaskTradePostWithHttpInfo(name: kotlin.String, simpleItemSchema: SimpleItemSchema) : ApiResponse<TaskTradeResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionTaskTradeMyNameActionTaskTradePostRequestConfig(name = name, simpleItemSchema = simpleItemSchema)

        return@withContext request<SimpleItemSchema, TaskTradeResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionTaskTradeMyNameActionTaskTradePost
     *
     * @param name Name of your character.
     * @param simpleItemSchema 
     * @return RequestConfig
     */
    fun actionTaskTradeMyNameActionTaskTradePostRequestConfig(name: kotlin.String, simpleItemSchema: SimpleItemSchema) : RequestConfig<SimpleItemSchema> {
        val localVariableBody = simpleItemSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/task/trade".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Unequip Item
     * Unequip an item on your character.
     * @param name Name of your character.
     * @param unequipSchema 
     * @return EquipmentResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionUnequipItemMyNameActionUnequipPost(name: kotlin.String, unequipSchema: UnequipSchema) : EquipmentResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionUnequipItemMyNameActionUnequipPostWithHttpInfo(name = name, unequipSchema = unequipSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EquipmentResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Unequip Item
     * Unequip an item on your character.
     * @param name Name of your character.
     * @param unequipSchema 
     * @return ApiResponse<EquipmentResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionUnequipItemMyNameActionUnequipPostWithHttpInfo(name: kotlin.String, unequipSchema: UnequipSchema) : ApiResponse<EquipmentResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionUnequipItemMyNameActionUnequipPostRequestConfig(name = name, unequipSchema = unequipSchema)

        return@withContext request<UnequipSchema, EquipmentResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionUnequipItemMyNameActionUnequipPost
     *
     * @param name Name of your character.
     * @param unequipSchema 
     * @return RequestConfig
     */
    fun actionUnequipItemMyNameActionUnequipPostRequestConfig(name: kotlin.String, unequipSchema: UnequipSchema) : RequestConfig<UnequipSchema> {
        val localVariableBody = unequipSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/unequip".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Use Item
     * Use an item as a consumable.
     * @param name Name of your character.
     * @param simpleItemSchema 
     * @return UseItemResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionUseItemMyNameActionUsePost(name: kotlin.String, simpleItemSchema: SimpleItemSchema) : UseItemResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionUseItemMyNameActionUsePostWithHttpInfo(name = name, simpleItemSchema = simpleItemSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UseItemResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Use Item
     * Use an item as a consumable.
     * @param name Name of your character.
     * @param simpleItemSchema 
     * @return ApiResponse<UseItemResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionUseItemMyNameActionUsePostWithHttpInfo(name: kotlin.String, simpleItemSchema: SimpleItemSchema) : ApiResponse<UseItemResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionUseItemMyNameActionUsePostRequestConfig(name = name, simpleItemSchema = simpleItemSchema)

        return@withContext request<SimpleItemSchema, UseItemResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionUseItemMyNameActionUsePost
     *
     * @param name Name of your character.
     * @param simpleItemSchema 
     * @return RequestConfig
     */
    fun actionUseItemMyNameActionUsePostRequestConfig(name: kotlin.String, simpleItemSchema: SimpleItemSchema) : RequestConfig<SimpleItemSchema> {
        val localVariableBody = simpleItemSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/use".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Withdraw Bank Gold
     * Withdraw gold from your bank.
     * @param name Name of your character.
     * @param depositWithdrawGoldSchema 
     * @return BankGoldTransactionResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionWithdrawBankGoldMyNameActionBankWithdrawGoldPost(name: kotlin.String, depositWithdrawGoldSchema: DepositWithdrawGoldSchema) : BankGoldTransactionResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionWithdrawBankGoldMyNameActionBankWithdrawGoldPostWithHttpInfo(name = name, depositWithdrawGoldSchema = depositWithdrawGoldSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BankGoldTransactionResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Withdraw Bank Gold
     * Withdraw gold from your bank.
     * @param name Name of your character.
     * @param depositWithdrawGoldSchema 
     * @return ApiResponse<BankGoldTransactionResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionWithdrawBankGoldMyNameActionBankWithdrawGoldPostWithHttpInfo(name: kotlin.String, depositWithdrawGoldSchema: DepositWithdrawGoldSchema) : ApiResponse<BankGoldTransactionResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRequestConfig(name = name, depositWithdrawGoldSchema = depositWithdrawGoldSchema)

        return@withContext request<DepositWithdrawGoldSchema, BankGoldTransactionResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionWithdrawBankGoldMyNameActionBankWithdrawGoldPost
     *
     * @param name Name of your character.
     * @param depositWithdrawGoldSchema 
     * @return RequestConfig
     */
    fun actionWithdrawBankGoldMyNameActionBankWithdrawGoldPostRequestConfig(name: kotlin.String, depositWithdrawGoldSchema: DepositWithdrawGoldSchema) : RequestConfig<DepositWithdrawGoldSchema> {
        val localVariableBody = depositWithdrawGoldSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/bank/withdraw/gold".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Action Withdraw Bank Item
     * Take items from your bank and put them in the character&#39;s inventory. The cooldown will be 3 seconds multiplied by the number of different items withdrawn.
     * @param name Name of your character.
     * @param simpleItemSchema 
     * @return BankItemTransactionResponseSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun actionWithdrawBankItemMyNameActionBankWithdrawItemPost(name: kotlin.String, simpleItemSchema: kotlin.collections.List<SimpleItemSchema>) : BankItemTransactionResponseSchema = withContext(Dispatchers.IO) {
        val localVarResponse = actionWithdrawBankItemMyNameActionBankWithdrawItemPostWithHttpInfo(name = name, simpleItemSchema = simpleItemSchema)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BankItemTransactionResponseSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Action Withdraw Bank Item
     * Take items from your bank and put them in the character&#39;s inventory. The cooldown will be 3 seconds multiplied by the number of different items withdrawn.
     * @param name Name of your character.
     * @param simpleItemSchema 
     * @return ApiResponse<BankItemTransactionResponseSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun actionWithdrawBankItemMyNameActionBankWithdrawItemPostWithHttpInfo(name: kotlin.String, simpleItemSchema: kotlin.collections.List<SimpleItemSchema>) : ApiResponse<BankItemTransactionResponseSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = actionWithdrawBankItemMyNameActionBankWithdrawItemPostRequestConfig(name = name, simpleItemSchema = simpleItemSchema)

        return@withContext request<kotlin.collections.List<SimpleItemSchema>, BankItemTransactionResponseSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation actionWithdrawBankItemMyNameActionBankWithdrawItemPost
     *
     * @param name Name of your character.
     * @param simpleItemSchema 
     * @return RequestConfig
     */
    fun actionWithdrawBankItemMyNameActionBankWithdrawItemPostRequestConfig(name: kotlin.String, simpleItemSchema: kotlin.collections.List<SimpleItemSchema>) : RequestConfig<kotlin.collections.List<SimpleItemSchema>> {
        val localVariableBody = simpleItemSchema
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/my/{name}/action/bank/withdraw/item".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get All Characters Logs
     * History of the last 250 actions of all your characters.
     * @param page Page number (optional, default to 1)
     * @param size Page size (optional, default to 50)
     * @return DataPageLogSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getAllCharactersLogsMyLogsGet(page: kotlin.Int? = 1, size: kotlin.Int? = 50) : DataPageLogSchema = withContext(Dispatchers.IO) {
        val localVarResponse = getAllCharactersLogsMyLogsGetWithHttpInfo(page = page, size = size)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DataPageLogSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get All Characters Logs
     * History of the last 250 actions of all your characters.
     * @param page Page number (optional, default to 1)
     * @param size Page size (optional, default to 50)
     * @return ApiResponse<DataPageLogSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getAllCharactersLogsMyLogsGetWithHttpInfo(page: kotlin.Int?, size: kotlin.Int?) : ApiResponse<DataPageLogSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getAllCharactersLogsMyLogsGetRequestConfig(page = page, size = size)

        return@withContext request<Unit, DataPageLogSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAllCharactersLogsMyLogsGet
     *
     * @param page Page number (optional, default to 1)
     * @param size Page size (optional, default to 50)
     * @return RequestConfig
     */
    fun getAllCharactersLogsMyLogsGetRequestConfig(page: kotlin.Int?, size: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/my/logs",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Character Logs
     * History of the last actions of your character.
     * @param name Name of your character.
     * @param page Page number (optional, default to 1)
     * @param size Page size (optional, default to 50)
     * @return DataPageLogSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCharacterLogsMyLogsNameGet(name: kotlin.String, page: kotlin.Int? = 1, size: kotlin.Int? = 50) : DataPageLogSchema = withContext(Dispatchers.IO) {
        val localVarResponse = getCharacterLogsMyLogsNameGetWithHttpInfo(name = name, page = page, size = size)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DataPageLogSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Character Logs
     * History of the last actions of your character.
     * @param name Name of your character.
     * @param page Page number (optional, default to 1)
     * @param size Page size (optional, default to 50)
     * @return ApiResponse<DataPageLogSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getCharacterLogsMyLogsNameGetWithHttpInfo(name: kotlin.String, page: kotlin.Int?, size: kotlin.Int?) : ApiResponse<DataPageLogSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getCharacterLogsMyLogsNameGetRequestConfig(name = name, page = page, size = size)

        return@withContext request<Unit, DataPageLogSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCharacterLogsMyLogsNameGet
     *
     * @param name Name of your character.
     * @param page Page number (optional, default to 1)
     * @param size Page size (optional, default to 50)
     * @return RequestConfig
     */
    fun getCharacterLogsMyLogsNameGetRequestConfig(name: kotlin.String, page: kotlin.Int?, size: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (size != null) {
                    put("size", listOf(size.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/my/logs/{name}".replace("{"+"name"+"}", encodeURIComponent(name.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get My Characters
     * List of your characters.
     * @return MyCharactersListSchema
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getMyCharactersMyCharactersGet() : MyCharactersListSchema = withContext(Dispatchers.IO) {
        val localVarResponse = getMyCharactersMyCharactersGetWithHttpInfo()

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MyCharactersListSchema
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get My Characters
     * List of your characters.
     * @return ApiResponse<MyCharactersListSchema?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getMyCharactersMyCharactersGetWithHttpInfo() : ApiResponse<MyCharactersListSchema?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getMyCharactersMyCharactersGetRequestConfig()

        return@withContext request<Unit, MyCharactersListSchema>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMyCharactersMyCharactersGet
     *
     * @return RequestConfig
     */
    fun getMyCharactersMyCharactersGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/my/characters",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
